vite =>

1. Fast 
2. Bundling is fast

1. npm create vite@latest auth-app
2. cd auth-app
3. npm install
4. npm run dev


type script is a programming language. JS but typed JS. TypeScript is a syntactic superset of JavaScript which adds static typing.

This basically means that TypeScript adds syntax on top of JavaScript, allowing developers to add types.

TypeScript being a "Syntactic Superset" means that it shares the same base syntax as JavaScript, but adds something to it.

types => all + any

react is for developers mostly


axios
material ui / tailwind
localstorage
react router

container => all components will be load
atomic principle
store will be wrap in container

component to container => container to pages

redux manages global level state

if added to cart => state will be component level
so redux
 so store => store will be in index.js

 cart component in store

reusable component


pages in route 


product pages
cart
wishlist
Login
SignUp
productdetails



react-helmet => for seo
npm install -D tailwindcss postcss autoprefixer


!!localStorage.getItem('token'):

The !! is a common JavaScript trick to convert a value to a boolean.
If 'token' is present in localStorage, localStorage.getItem('token') will return the token as a string, and !! will convert it to true.
If 'token' is not present, localStorage.getItem('token') will return null, and !! will convert it to false.


useState(!!localStorage.getItem('token')):

useState is a React hook that manages state in functional components.
The initial value of isAuthenticated is set to true if there is a 'token' in localStorage, and false otherwise.








//Higher order component
// const Wrapper = (Component) => (props) => {
//     const data = "{}"
//     return (
//         <Component data={data}/>
//     )
// }

// const Product1 = () => {

// }

// const Product2 = () => {

// }

// Wrapper(Product2)






    // <CParent>
    //     <Child></Child>
    // </CParent>

    // <Slider renderGallery={ <h1>Hello I am Gallery</h1> } />

    // return (


    // )









Flow Breakdown:
User Clicks on the Wishlist Icon:

When the user clicks on the heart icon, the handleWishlistClick function is called:

<FaHeart
    onClick={handleWishlistClick}
    style={{ color: isInWishlist ? 'red' : 'gray', cursor: 'pointer' }}
/>
handleWishlistClick Calls handleAddToWishlist:

The handleWishlistClick function triggers the handleAddToWishlist function, passing the current product as an argument:
javascript
Copy code
const handleWishlistClick = () => {
    handleAddToWishlist(product);
};
handleAddToWishlist Updates the wishlist:

Inside handleAddToWishlist, the wishlist state is updated. If the product is already in the wishlist, it is removed; otherwise, it is added:
javascript
Copy code
const handleAddToWishlist = (product) => {
    setWishlist(prevWishlist => {
        const isProductInWishlist = prevWishlist.some(wishlistItem => product.id === wishlistItem.id);
        if (isProductInWishlist) {
            return prevWishlist.filter(wishlistItem => wishlistItem.id !== product.id);
        } else {
            return [...prevWishlist, product];
        }
    });
};
State Update: setWishlist triggers a re-render of the component, and the new wishlist state is passed down to the ProductCard component.
useEffect Reacts to wishlist Change:

Since wishlist is a dependency of the useEffect hook, React detects the change in wishlist and re-runs the effect:
javascript
Copy code
useEffect(() => {
    let isProductInWishlist = false;
    if (wishlist) {
        isProductInWishlist = wishlist.some(wishlistItem => product.id === wishlistItem.id);
    }
    setIsInWishlist(isProductInWishlist);
}, [wishlist]);
Effect Logic: The effect checks if the current product is now in the updated wishlist and updates the isInWishlist state.
Component Re-render:

When isInWishlist changes, React re-renders the ProductCard component. This re-render updates the heart icon's color, reflecting whether the product is in the wishlist (red) or not (gray).
Summary:
User Action: Clicking the heart icon triggers the handleWishlistClick function.
State Update: handleAddToWishlist updates the wishlist state.
Effect Trigger: The useEffect hook automatically re-runs when wishlist changes, checking if the product is in the wishlist and updating isInWishlist.
UI Update: The component re-renders, showing the updated wishlist status visually.
This flow ensures that the UI responds automatically to changes in the wishlist, providing immediate feedback to the user.



















I am not getting correct output, after clicking on add to cart at first console gives empty array and after second add to cart its showing previous item added to cart, output as follows =>>[]length: 0[[Prototype]]: Array(0)
Product.jsx:27 [{…}]0: {id: 3, title: 'Mens Cotton Jacket', price: 55.99, description: 'great outerwear jackets for Spring/Autumn/Winter, …and or son in this thanksgiving or Christmas Day.', category: "men's clothing", …}length: 1[[Prototype]]: Array(0)
Product.jsx:27 (2) [{…}, {…}]0: {id: 3, title: 'Mens Cotton Jacket', price: 55.99, description: 'great outerwear jackets for Spring/Autumn/Winter, …and or son in this thanksgiving or Christmas Day.', category: "men's clothing", …}1: {id: 3, title: 'Mens Cotton Jacket', price: 55.99, description: 'great outerwear jackets for Spring/Autumn/Winter, …and or son in this thanksgiving or Christmas Day.', category: "men's clothing", …}length: 2[[Prototype]]: Array(0)

The issue you're encountering is related to how the setState function works in React. When you call setCart, the cart state isn't updated immediately, so when you log it right after calling setCart, you see the previous state instead of the current one.

Here’s how you can address this:

Update the handleAddToCart Function
Instead of directly updating the cart state with the previous cart array, you can use the functional form of setState, which ensures you're working with the latest state.

function handleAddToCart(product) {
    setCart(prevCart => {
        const updatedCart = [...prevCart, product];
        console.log(updatedCart); // This will now show the correct cart content
        return updatedCart;
    });
}


Explanation:
Functional setState: By using the functional form setCart(prevCart => ...), you ensure that the latest state (prevCart) is used when updating the cart state. This avoids issues with stale state when you have multiple rapid state updates.

Console Logging: The console.log(updatedCart) will now correctly log the cart's state after the product is added.



/* import React from "react";
import ProductList from "../components/ProductList.jsx";

class ProductContainer extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            products: [
               
            ],
            cartCount:0,
            cart : [],
            productList : []
        };

    this.getProducts =  this.getProducts.bind(this);
    this.handleAddToCart = this.handleAddToCart.bind(this);

    }

    componentDidMount(){
        console.log("Mounted");
        this.getProducts();
    } 

    componentDidUpdate(){
        console.log("Updated")
    }

    
    getProducts(){
        fetch('https://fakestoreapi.com/products')
            .then(res=>res.json())
            .then(data => {
                this.setState({products : data});
            });
    }

    handleAddToCart(){
        const { cartCount } = this.state;
        this.setState({ cartCount : cartCount + 1})
    }
    


    render() {
        const { products,cartCount } = this.state;
        
        return (
            <>
                <div>
                    <h1>Product <span>Cart count : {cartCount}</span></h1>

                    <div>
                        <ProductList products={products} handleAddToCart={this.handleAddToCart} />
                        <Header products={products} handleAddToCart={this.handleAddToCart} />
                    </div>
                </div>
            </>
        );
    }
}


export default ProductContainer;  */